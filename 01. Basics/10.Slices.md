# Slices or Variable size Arrays

- Often, we do not know how beforehand the size of our arrays. So, we need dynamic and flexible arrays that can store multiple values and can dynamically increase or decrease their sizes.
- They can grow or shrink dynamically.


## Declaration without initialization

- Size is not specified.
- Gets assigned a special value of `nil`. 

```go
var a []int8
fmt.Println(a == nil) // true
```

## Initilaization

```go
func main() {
	var a []int8 = []int8{1, 2, 3, 4}

	fmt.Println(a) // [1,2,3,4]
}

```

## Slice are passed by reference

```go
var slice1 = []int{1, 2, 3, 4, 5}
var slice2 = slice1

slice2[0] = 9

fmt.Println(slice1) // [9 2 3 4 5]
fmt.Println(slice2) // [9 2 3 4 5]
```

## Make

- Takes two arguments. Type and initial size.
- Returns a slice initialized with default values.

```go
func main() {
	var a = make([]int8, 5)

	fmt.Println(a) // [0 0 0 0 0]
}
```

## Create a slice from an array

- Lower bound includes and upper bound excluded.
- Should be 0 to n.


```go
func main() {
	var a = [5]int8{1, 2, 3, 4, 5}

	slice := a[0:5]

	fmt.Println(slice)
}
```

## Append(slice, elements) : New slice

- Creates a new slice.
- Copies elements from input slice. Adds new elements to it.
- Returns new slice.

```go
var slice = []int{1, 2, 3, 4, 5}

slice1 := append(slice, 6, 7)

fmt.Println(slice, slice1)
```

## Copy(destinationSlice, sourceSlice)

- Creates a new slice from input slice.
- Both are referring to different slices. Updating one doesn't affects teh other.


```go
func main() {
	var slice = []int{1, 2, 3, 4, 5}
	slice2 := make([]int, len(slice))

	copy(slice2, slice)

	fmt.Println(slice, slice2)
}

```


## Iterating over slices

- We can use traditional for loop from o to n-1.
- We can use the range function

```go
func main() {
	var slice = []int{1, 2, 3, 4, 5}

	for i := 0; i < len(slice); i++ {
		fmt.Printf("INDEX:: %d VALUE:: %d \n", i, slice[i])
	}

	for i, v := range slice {
		fmt.Println(i, v)
	}
}
```

## Comparing two slices

- Every value is chcked. Deep equality

```go
func main() {
	var slice1 = []int{1, 2, 3, 4, 5}
	var slice2 = []int{1, 2, 3, 4, 5}

	fmt.Println(slices.Equal(slice1, slice2)) // true
}
```

## Slice operator [low:high]

- To get a part of the slice.
- Low is inclusive , high is not.
- Returns a new slice.

```go
func main() {
	var slice1 = []int{1, 2, 3, 4, 5}

	slice2 := slice1[0:len(slice1)]

	fmt.Println(slice2) // [1 2 3 4 5]
}
```

- If high is omitted, it takes length of the input slice.

```go
func main() {
	var slice1 = []int{1, 2, 3, 4, 5}

	slice2 := slice1[0:]

	fmt.Println(slice2) // [1 2 3 4 5]
}

```

## Capacity vs Length

- Len is the number of elements present in the slice at any moment.
- Cap is the total capacity of the slice that it can grow into without rellocation.
