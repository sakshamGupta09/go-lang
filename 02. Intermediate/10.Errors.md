# Errors

- There are some operations which are expected to fail sometimes like conecting to a DB or making a network request. So, we need a way to handle these errors.

## Using errors package

- `error` is a built in type.
- Do an operation. If it succeds give me the result else give me the error. Caller will be able to know if the task failed or succeded.
- `errors.New` returns `error` interface.

```go
func main() {
	result, err := operation(-10)
	fmt.Println(result, err)
}

func operation(num int) (int, error) {
	if num < 0 {
		return 0, errors.New("ERROR:: Negative numbers not allowed")
	}
	return 1, nil
}
```

## Shorthand

```go
	if _, err := operation(-2); err != nil {
		fmt.Println("ERROR")
	}
```


## Defining custom errors

- If we want to have some additional information to our error, we can define a custom type.

 1️⃣ Defining a custom error type

```go
type customError struct {
	statusCode int16
	message    string
}
```

2️⃣ Making customError behave like a Go error

The built-in `error` interface looks like this:

```go
type error interface {
	Error() string
}
```
Any struct that will define this method will implement `error` interface.

```go
func (e customError) Error() string {
	return fmt.Sprintf("ERROR::%s %d", e.message, e.statusCode)
}
```

3️⃣ The operation function

```go
func operation() error {
	return customError{statusCode: 401, message: "UNAUTHORIZED"}
}

func main() {
	err := operation()
	fmt.Println(err)
}
```

- We are simply returning a initialized `struct`.
- But when we print it's value, internally it calls `Error` method and return the formatted output.


## fmt.Errorf

- `%w` is a special formatting verb used ONLY with errors.
- It wraps one error inside another error.

```go
var ErrUnauthorized = errors.New("unauthorized")

func login() error {
	return ErrUnauthorized
}

func handler() error {
	err := login()
	if err != nil {
		return fmt.Errorf("login failed: %w", err)
	}
	return nil
}

```
