# Errors

- There are some operations which are expected to fail sometimes like conecting to a DB or making a network request. So, we need a way to handle these errors.

## Using errors package

- `error` is a built in type.
- Do an operation. If it succeds give me the result else give me the error. Caller will be able to know if the task failed or succeded.
- `errors.New` returns `error` interface.

```go
func main() {
	result, err := operation(-10)
	fmt.Println(result, err)
}

func operation(num int) (int, error) {
	if num < 0 {
		return 0, errors.New("ERROR:: Negative numbers not allowed")
	}
	return 1, nil
}
```

## Shorthand

```go
	if _, err := operation(-2); err != nil {
		fmt.Println("ERROR")
	}
```


## Defining custom errors

- If we want to have some additional information to our error, we can define a custom type that will implement `error` interface.
