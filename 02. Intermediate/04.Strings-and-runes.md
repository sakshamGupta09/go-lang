
# How computers store characters

- Machines only understand bits and bytes. So, how are characters stored?
- Every character in this world(in any language or emojis) has a unicode number.
- UTF-8 encoding is a mechanism which takes a character and computes it's binary representation.
- Different characters can take different bytes in memory. English alphabets takes 1 byte. Emojis can take 4 bytes.

## Strings

- String is a sequence of bytes.
- Strings are immutable. Once created they cannot be modified. We have to create a new string if we need to modify a string.
- `a` has ASCII value of 97 and `A` 65.

``` go
s := "hello"

h  e  l  l  o
68 65 6c 6c 6f   ‚Üê bytes

```

## len function

- It counts number of bytes.

```go
func main() {
	var r string = "‡§πüôÇ"
	fmt.Println(len(r)) // 7
}
```

## Runes

utf8.RuneCountInString


## Double quotes vs Raw string literal (Backticks)

- There are two ways to store a string value. Using double quotes and back ticks. Single quotes does not work.

## Escape sequences

- `\n` New Line, `\t` Tab space, `\r` Carriage return which moves the cursor to the beginning of the current line.
- Raw string literal does not resepct escape characters. It just treates them as another character.


```go
func main() {
	name := "John \n Doe"
	name2 := `John \n Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
		  John
		  Doe
	    John \n Doe
	*/

}
```

```go
func main() {
	name := "John \t Doe"
	name2 := `John \t Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
		John     Doe
	  John \t Doe	*/

}

```

```go
func main() {
	name := "John\rDoe"
	name2 := `John \r Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
	Doen
	John \r Doe
	*/

}
```

## len

- We can use the `len` function to calculate length of a string.
- If using double quotes, escape sequence is considered one character.
- However, with raw string literal escape sequences are considered two seperate characters `\` and `n`.

```go
func main() {
	name := "John\nDoe"
	name2 := `John\rDoe`

	fmt.Println(len(name))
	fmt.Println(len(name2))

	/*
		8
		11
	*/

}
```

## Concat strings

- `+` operator is used to cancat two strings.

## Comparing strings

- Strings are compared via ASCII values.
- If we have same prefix but different length shorter is smaller based on lexicographic ordering.

```go
func main() {
	fmt.Println("Apple" > "apple")
	fmt.Println("apple" > "app")
	/*
			false
	    true
	*/
}
```

## Format verbs

- Think of them as instructions that say ‚Äúprint this value like this‚Äù.

| Verb   | Used For                 | Example              |
| ------ | ------------------------ | -------------------- |
| `%v`   | Default value (any type) | `{Aman 30}`          |
| `%+v`  | Struct with field names  | `{Name:Aman Age:30}` |
| `%T`   | Type of value            | `int`, `[]string`    |
| `%d`   | Integers                 | `42`                 |
| `%f`   | Floating point           | `3.141590`           |
| `%.2f` | Float with precision     | `3.14`               |
| `%s`   | String                   | `golang`             |
| `%t`   | Boolean                  | `true`               |
| `%p`   | Pointer address          | `0xc0000140a0`       |
| `%%`   | Literal percent          | `%`                  |
| `%c`   | Unicode character        | `A`                  |



## Iterating over strings

- We can use traditional for loop as well as range function.

```go
func main() {
	name := "Hello world"

	for i, char := range name {
		fmt.Printf("INDEX: %d VALUE: %c \n", i, char)
	}

	/*
		INDEX: 0 VALUE: H
		INDEX: 1 VALUE: e
		INDEX: 2 VALUE: l
		INDEX: 3 VALUE: l
		INDEX: 4 VALUE: o
		INDEX: 5 VALUE:
		INDEX: 6 VALUE: w
		INDEX: 7 VALUE: o
		INDEX: 8 VALUE: r
		INDEX: 9 VALUE: l
		INDEX: 10 VALUE: d
	*/
}
```
