# JSON

- JSON is a lightweight, text-based format used to store and exchange data.
- A common language computers use to share data. Works with JavaScript, Go, Python, Java, etc.

## Converting structs to JSON (Marshalling)

- For every `struct` field, we need to define corresponsing JSON field in backticks.
- This is useful because our struct might be public and so we need to make the fields capitalCase. But in JSON, we might be following different naming conventions.

```go
type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	person := Person{Name: "John Doe", Age: 28}

	jsonData, err := json.Marshal(person)

	if err != nil {
		fmt.Println("ERROR::", err)
		return
	}

	fmt.Println(string(jsonData))
}
```

## omitempty

- While converting to `JSON`, if a field is having no value in struct, we can omit it from final `JSON` representation.
- If not it will take it's default value.

```go
type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age,omitempty"`
}

func main() {
	person := Person{Name: "John Doe"}

	jsonData, err := json.Marshal(person)

	if err != nil {
		fmt.Println("ERROR::", err)
		return
	}

	fmt.Println(string(jsonData)) // {"name":"John Doe"}
}

```

## Nested structs

```go
type Person struct {
	Name    string  `json:"name"`
	Age     int     `json:"age,omitempty"`
	Address Address `json:"address"`
}

type Address struct {
	City  string `json:"city"`
	State string `json:"state"`
}

func main() {
	person := Person{Name: "John Doe", Age: 28, Address: Address{City: "Jammu", State: "Jammu and Kashmir"}}

	jsonData, err := json.Marshal(person)

	if err != nil {
		fmt.Println("ERROR::", err)
		return
	}

	fmt.Println(string(jsonData))

	// {"name":"John Doe","age":28,"address":{"city":"Jammu","state":"Jammu and Kashmir"}}
}
```

## Unmarshal

- Convert `JSON` to structs. Let's say our BE si sending `JSON` response and we need to convert it into a struct.
- When we pass a variable to a function, it is passed by value. So, we need to pass address of variable so it gets the value stored in original variable.
- We have already defined the mapping using `json:"fieldName"`.

```go
type Person struct {
	Name    string  `json:"name"`
	Age     int     `json:"age,omitempty"`
	Address Address `json:"address"`
}

type Address struct {
	City  string `json:"city"`
	State string `json:"state"`
}

func main() {
	response := `{"name":"John Doe","age":28,"address":{"city":"Jammu","state":"Jammu and Kashmir"}}`

	var person Person

	err := json.Unmarshal([]byte(response), &person)

	if err != nil {
		fmt.Println("Something went wrong", err)
		return
	}

	fmt.Println(person)
```


## Convert slice to JSON

```go
func main() {
	list := []Address{
		{City: "City1", State: "State1"},
		{City: "City2", State: "State2"},
		{City: "City3", State: "State3"},
	}

	json, err := json.Marshal(list)

	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(json))

	// [{"city":"City1","state":"State1"},{"city":"City2","state":"State2"},{"city":"City3","state":"State3"}]

}
```

## Convert JSON to slice

```go
func main() {
	jsonData := `[{"city":"City1","state":"State1"},{"city":"City2","state":"State2"},{"city":"City3","state":"State3"}]`

	var list []Address

	json.Unmarshal([]byte(jsonData), &list)

	fmt.Println(list)
}
```
