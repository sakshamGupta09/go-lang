# How text works in programming

- Computers can only store bytes. They can't store strings or characters.
- How is text usually stored in programming languages?
- We need a way to convert characters to bytes.

1ï¸âƒ£ Step 1: Unicode assigns a number to every character

- Unicode gives a unique number to 



## Strings

- A string is a read-only slice of bytes.
- Each byte is a `uint8` whose value ranges from 0 to 255.
- 

``` go
s := "hello"

h  e  l  l  o
68 65 6c 6c 6f   â† bytes

```

## len function

- It counts number of bytes not number of characters.
- Generally english alphabets take up 1 byte so it gives accurate results.

```go
func main() {
	var r string = "à¤¹ðŸ™‚"
	fmt.Println(len(r)) // 7
}
```

## Runes

- A rune is one character (Unicode character).
- They are declared with single quotes.
- Rune is a sperate type but is `int32` behind the scenes.

```go
func main() {
	var r rune = 'a'

	fmt.Println(r) // 97
}
```

## utf8.RuneCountInString

- Counts number of unicode characters in a string.

```go
utf8.RuneCountInString("ðŸ™‚") // 1
```

## Double quotes vs Raw string literal (Backticks)

- Strings can be created using double quotes and back ticks. Single quotes does not work.
- Backtick or raw string literal does not respect escape sequences.

## Escape sequences

### `\n` New line. It starts a new line.

```go
func main() {
	name := "John \n Doe"
	name2 := `John \n Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
		  John
		  Doe
	    John \n Doe
	*/

}
```

### `\t` It adds a tab space

```go
func main() {
	name := "John \t Doe"
	name2 := `John \t Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
		John     Doe
	  John \t Doe	*/

}

```

### Carriage return `\r`. It takes the cursor to the begining of line and starts replacing characters

```go
func main() {
	name := "John\rDoe"
	name2 := `John \r Doe`

	fmt.Println(name)
	fmt.Println(name2)

	/*
	Doen
	John \r Doe
	*/

}
```

### With raw string literal, escape sequence is treated as seperate characters. So, the len function will return different results.


```go
func main() {
	var name = "Hello\nWorld"
	var name2 = `Hello\nWorld`

	fmt.Println(len(name), len(name2))                                       // 11 12
	fmt.Println(utf8.RuneCountInString(name), utf8.RuneCountInString(name2)) // 11 12

}
```

## Iterating over strings

- We can use traditional for loop as well as range function.
- Since, characters are stored as numbers in memory, when we access char from string, we get back a number.

```go
func main() {
	name := "Hello World à¤¹ðŸ™‚"

	for i, char := range name {
		fmt.Println(i, char)
	}

	/*
		0 72
		1 101
		2 108
		3 108
		4 111
		5 32
		6 87
		7 111
		8 114
		9 108
		10 100
		11 32
		12 2361
		15 128578
	*/
}
```


## Concat strings

- `+` operator is used to cancat two strings.

## Comparing strings

- Strings are compared via ASCII values. It's like comparing numbers one by one.
- If we have same prefix but different length shorter is smaller based on lexicographic ordering.

```go
func main() {
	fmt.Println("Apple" > "apple")
	fmt.Println("apple" > "app")
	/*
			false
	    true
	*/
}
```

## Convert rune to string

```go
func main() {
	var r rune = 'a'

	name := string(r)

	fmt.Printf("%T", name)
}
```
