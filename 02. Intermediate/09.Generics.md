# Generics

## Problem

- We are working with a stack data structure.
- It can be an integer, float, string or a boolean stack.
- How do we make our stack this flexible that it can support multiple data types without duplicating code and without losing type safety.


## Without generics

- We can use any type which can lead to runtime issues and losing type safety.
- We can duplicate our code to create integerStack, FloatStack etc


## Generics

- Generics lets us define functions and types that can work with multiple data types without duplication or losing type safety.
- We declare our functions and type with a placeholder type T and when we instantiate our type or call our function, we supply the value of T

```go
func SumInts(a, b int) int {
	return a + b
}

func SumFloats(a, b float64) float64 {
	return a + b
}
```

```go
func add[T int | float64](a, b T) T {
	return a + b
}
```
```go
func PrintSlice[T any](items []T) {
	for _, v := range items {
		fmt.Println(v)
	}
}

PrintSlice([]int{1, 2, 3})
PrintSlice([]string{"go", "is", "fun"})

```

## A generic Stack

### Define a generic type for struct

``` go
type Stack[T any] struct {
	items []T
}
```

### Generic methods on Stack

```go
func (s *Stack[T]) IsEmpty() bool {
	return len(s.items) == 0
}

func (s *Stack[T]) Push(element T) {
	s.items = append(s.items, element)
}

func (s *Stack[T]) Pop() (bool, T) {
	if s.IsEmpty() {
		var zero T
		return false, zero
	}
	size := len(s.items)
	last := s.items[size-1]

	s.items = s.items[:size-1]
	return true, last
}
```

### How to use

```go
func main() {
	intStack := Stack[int8]{items: []int8{1, 2, 3}}
	fmt.Println(intStack)

	intStack.Push(4)
	fmt.Println(intStack)
	intStack.Push(5)
	fmt.Println(intStack)

}
```
