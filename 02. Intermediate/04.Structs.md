# Structs

- A real world entity can have multiple attributes and behavior. Like a user can have `name`, `age`, `email` and so on.
- A struct is way to create your own data type by grouping multiple related fields under one logical unit.


## Declaring a struct

- Structs should be declared at package level.
- We define te structure of our entity, a blueprint following which we can create multiple instances.

```go
type Person struct {
	firstName string
	lastName  string
	age       int8
}
```

## Initialization

```go
func main() {
	p := Person{
		firstName: "John",
		lastName:  "Doe",
		age:       25,
	}

	fmt.Println(p)
}
```
- It's okay to omit some fields while initializing a struct type.
- If we don't initialize a field, it gets initialized with zero value of that type.


## Accessing fields

- Dot notation


## Anonymous structs

```go
user := struct {
    Name string
    Age  int
}{
    Name: "Saksham",
    Age:  28,
}

```

## Structs are passed by value

```go
func main() {
	p := Person{
		firstName: "John",
		lastName:  "Doe",
		age:       31,
	}

	q := p
	q.firstName = "Q"

	fmt.Println(p.firstName, q.firstName)
}
```

## Methods

- Should be declared at package level and outside the struct.
- Struct instances are able to access this method and automatically receive a copy of the instance in receiver function. Modifying this copy will not change original instance as structs are passed by value.

```go
func (p Person) greetUser() string {
	p.firstName = "James"
	p.lastName = "Murr"

	return p.firstName + p.lastName
}
```


## Pointer receiver

- To modify struct fields from inside a method.

```go
func (p *Person) greetUser() {
	p.age++
}
```

## Embedding

- We can embed structs within a struct.

```go
type Address struct {
	city    string
	country string
}

type Person struct {
	firstName string
	lastName  string
	age       int8
	address   Address
}

p := Person{
	firstName: "John",
	lastName:  "Doe",
	age:       31,
	address: Address{
		city:    "LA",
		country: "USA",
	},
}
```

## Embedded Anonymous field

- It pulls out the struct values to the outer struct level. So, all the sub properties of embedded struct can be directly accesses by outer struct as if it were part of it's declaration.

```go
type Hobbies struct {
	name string
}

type Person struct {
	firstName string
	lastName  string
	age       int8
	address   Address
	Hobbies
}

p := Person{
	firstName: "John",
	lastName:  "Doe",
	age:       31,
	address: Address{
		city:    "LA",
		country: "USA",
	},
	Hobbies: Hobbies{
		name: "Cricket",
	},
}

fmt.Println(p.address.city)
fmt.Println(p.name)
```

## Comparing structs

- Using `==`
- Deep comparison
