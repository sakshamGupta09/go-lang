# Closures

- A function is able to retain access to its lexical (enclosing) scope, even after that surrounding function has finished executing.
- Encapsulation as data and methods that update that data are together.
- It also lets us creates private state which is not accessible to outside world.


```go
func main() {
	incrementByOne := counter()

	fmt.Println(incrementByOne())
	fmt.Println(incrementByOne())
	fmt.Println(incrementByOne())

}

func counter() func() int {
	count := 0

	return func() int {
		count++
		return count
	}
}
```

- Whenever counter is called, it returns a function that can access `count` state variable and read it's value.
- `incrementByOne` is a function that has access to a state called count whose initial value is 0. This function can update the state.
- If we call counter function again, a new function will be returned with state set to 0 initially.
- If the function reference is same, the state value will persist. Operations will be performed on persisted state.




