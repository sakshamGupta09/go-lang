# Closures

- A function is able to retain access to its outer environment or lexical (enclosing) scope.
- Encapsulation as data and methods that update that data are together.
- It also lets us creates private state which is not accessible to outside world.
- Closures can keep the variables alive that otherwise would be garbage collected. So, closures can be memory extensive.


```go
func main() {
	incrementByOne := counter()

	fmt.Println(incrementByOne())
	fmt.Println(incrementByOne())
	fmt.Println(incrementByOne())

}

func counter() func() int {
	count := 0

	return func() int {
		count++
		return count
	}
}
```

- Whenever counter is called, it returns a `function` that has access to it's lexical scope `count` state.
- `incrementByOne` is a function that has access to a state called count whose initial value is 0. This function can update the state.
- If we call `counter` function again, a new function will be returned with state set to `0` initially.
- If the function reference is same, the state value will persist. Operations will be performed on persisted state.



